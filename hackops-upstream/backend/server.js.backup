import express from "express";
import cors from "cors";
import dotenv from "dotenv";
import multer from "multer";
import fs from "fs";
import path from "path";
import { GoogleGenerativeAI } from "@google/generative-ai";
import { createServer } from "http";
import { WebSocketServer } from "ws";
import SpeechToTextService from "./services/speechToTextService.js";

dotenv.config();

const app = express();
const server = createServer(app);
const wss = new WebSocketServer({ server });
const port = process.env.PORT || 4000;

// Initialize Speech-to-Text service
const speechService = new SpeechToTextService();

app.use(cors());
app.use(express.json({ limit: "5mb" }));

const dataDir = path.resolve(process.cwd(), "data");
const uploadsDir = path.join(dataDir, "uploads");
const extractedDir = path.join(dataDir, "extracted");

for (const dir of [dataDir, uploadsDir, extractedDir]) {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, uploadsDir),
  filename: (req, file, cb) => {
    const safeName = file.originalname.replace(/[^a-zA-Z0-9_.-]/g, "_");
    cb(null, `${Date.now()}_${safeName}`);
  },
});
const upload = multer({ storage });

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || "");
const model = () => genAI.getGenerativeModel({ model: "gemini-1.5-flash" });

// Simple LRU cache with TTL for resources
const CACHE_TTL_MS = 6 * 60 * 60 * 1000; // 6 hours
const CACHE_MAX = 200;
const cache = new Map(); // key -> { data, ts }

function cacheGet(key) {
  const hit = cache.get(key);
  if (!hit) return null;
  if (Date.now() - hit.ts > CACHE_TTL_MS) { cache.delete(key); return null; }
  cache.delete(key); cache.set(key, hit); // refresh LRU
  return hit.data;
}
function cacheSet(key, data) {
  if (cache.has(key)) cache.delete(key);
  cache.set(key, { data, ts: Date.now() });
  if (cache.size > CACHE_MAX) cache.delete(cache.keys().next().value);
}
function makeKey({ topic, level, count }) {
  return `${(topic||"").toLowerCase().trim()}|${(level||"").toLowerCase()}|${count}`;
}

function scoreResume(text) {
  const signals = {
    projects: /(project|built|developed)\b/i.test(text) ? 1 : 0,
    internships: /(intern|internship)\b/i.test(text) ? 1 : 0,
    leadership: /(led|leader|captain|president)\b/i.test(text) ? 1 : 0,
    impact: /(increased|reduced|improved|optimized|achieved|%|percent)\b/i.test(
      text
    )
      ? 1
      : 0,
    skills: /(react|node|python|java|aws|sql|typescript|ml|ai)\b/i.test(text)
      ? 1
      : 0,
  };
  const total = Object.values(signals).reduce((a, b) => a + b, 0);
  const score = Math.round((total / 5) * 100);
  return { score, signals };
}

function buildSystemPrompt(resumeText, scoreObj) {
  return `You are a helpful career assistant.
You have access to the student's resume content below and a heuristic score.
- Resume score: ${scoreObj.score}/100
- Signals: ${JSON.stringify(scoreObj.signals)}

Use the resume to tailor advice, examples, and suggestions. When asked to write bullets, produce concise, quantified bullets. If information is missing, ask clarifying questions.`;
}

app.post("/api/upload-resume", upload.single("file"), async (req, res) => {
  try {
    if (!req.file) return res.status(400).json({ error: "No file uploaded" });
    const filePath = req.file.path;
    const ext = path.extname(filePath).toLowerCase();
    let extractedText = "";

    if (ext === ".pdf") {
      try {
        const { default: pdfParse } = await import("pdf-parse");
        const pdfData = await pdfParse(fs.readFileSync(filePath));
        extractedText = pdfData.text || "";
      } catch (e) {
        console.warn("PDF parse failed, falling back to placeholder context:", e?.message || e);
        extractedText = `PDF resume uploaded: ${path.basename(
          filePath
        )}. If text extraction is incomplete, ask the user to paste education, projects, and skills.`;
      }
    } else if ([".png", ".jpg", ".jpeg", ".webp"].includes(ext)) {
      // Basic fallback: store note; real OCR could be added later.
      extractedText = `Image resume uploaded: ${path.basename(
        filePath
      )}. Ask user to confirm key details (education, projects, skills).`;
    } else {
      // Try reading as text
      try {
        extractedText = fs.readFileSync(filePath, "utf8");
      } catch {
        extractedText = "";
      }
    }

    const extractedPath = path.join(
      extractedDir,
      `${path.basename(filePath)}.txt`
    );
    fs.writeFileSync(extractedPath, extractedText, "utf8");

    const scoreObj = scoreResume(extractedText);

    // Persist a conversation context file
    const context = {
      resumeFile: path.basename(filePath),
      extractedFile: path.basename(extractedPath),
      extractedTextLength: extractedText.length,
      score: scoreObj,
      createdAt: new Date().toISOString(),
    };
    const contextId = path.basename(filePath);
    fs.writeFileSync(
      path.join(dataDir, `${contextId}.json`),
      JSON.stringify(context, null, 2)
    );

    res.json({
      contextId,
      score: scoreObj.score,
      signals: scoreObj.signals,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to process resume" });
  }
});

app.post("/api/chat", async (req, res) => {
  try {
    const { contextId, message } = req.body;
    if (!message) return res.status(400).json({ error: "message is required" });

    let resumeText = "";
    let scoreObj = { score: 0, signals: {} };
    if (contextId) {
      const ctxPath = path.join(dataDir, `${contextId}.json`);
      if (fs.existsSync(ctxPath)) {
        const ctx = JSON.parse(fs.readFileSync(ctxPath, "utf8"));
        const extractedPath = path.join(extractedDir, ctx.extractedFile);
        if (fs.existsSync(extractedPath)) {
          resumeText = fs.readFileSync(extractedPath, "utf8");
          scoreObj = ctx.score || scoreObj;
        }
      }
    }

    const systemPrompt = buildSystemPrompt(resumeText, scoreObj);
    const userPrompt = `User message: ${message}

Relevant resume excerpt (may be empty):\n\n${resumeText.slice(
      0,
      4000
    )}\n\nBased on the resume, provide tailored guidance.`;

    if (!process.env.GEMINI_API_KEY) {
      // Fallback in dev without API key
      return res.json({
        reply: `[DEV MODE] ${systemPrompt}\n\n${userPrompt.slice(0, 500)}`,
      });
    }

    const result = await model().generateContent(systemPrompt + "\n\n" + userPrompt);
    const text = result.response.text();
    res.json({ reply: text });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Chat failed" });
  }
});

// Gemini-powered learning resources for a topic/skills
app.post("/api/resources", async (req, res) => {
  try {
    const { topic, skills, level, count = 8 } = req.body || {};
    const query = topic || (Array.isArray(skills) ? skills.join(", ") : "");
    if (!query) return res.status(400).json({ error: "topic or skills required" });

    const key = makeKey({ topic: query, level, count });
    const cached = cacheGet(key);
    if (cached) return res.json(cached);

    const jsonSchema = {
      type: "object",
      properties: {
        topic: { type: "string" },
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              title: { type: "string" },
              type: { type: "string", enum: ["article", "video"] },
              url: { type: "string" },
              description: { type: "string" },
              source: { type: "string" },
              duration: { type: "string" },
              level: { type: "string" }
            },
            required: ["title", "type", "url"]
          }
        }
      },
      required: ["items"]
    };

    // Dev fallback without API key
    if (!process.env.GEMINI_API_KEY) {
      const devData = {
        topic: query,
        items: [
          {
            title: "React Docs – Main Concepts",
            type: "article",
            url: "https://react.dev/learn",
            description: "Official learning path for modern React.",
            source: "react.dev",
            level: "Beginner"
          },
          {
            title: "React Router Tutorial",
            type: "article",
            url: "https://reactrouter.com/en/main/start/tutorial",
            description: "Routing fundamentals with examples.",
            source: "reactrouter.com",
            level: "Beginner"
          },
          {
            title: "React Hooks in 100 Seconds",
            type: "video",
            url: "https://www.youtube.com/watch?v=TNhaISOUy6Q",
            description: "Quick intro to hooks.",
            source: "YouTube",
            duration: "2m",
            level: "Beginner"
          }
        ]
      };
      cacheSet(key, devData);
      return res.json(devData);
    }

    const prompt = `
Return high-quality learning resources for: "${query}" (level: ${level || "auto"}).
- 8–12 items total, balanced mix of articles and YouTube videos, reputable and recent.
- concise 1–2 line descriptions, ordered fundamentals → advanced.
Respond ONLY as minified JSON matching this schema: ${JSON.stringify(jsonSchema)}
(count=${count})
`;

    const genCall = model().generateContent(prompt).then(r => r.response.text());
    const timeout = new Promise((_, rej) => setTimeout(() => rej(new Error("TIMEOUT")), 2500));
    const text = await Promise.race([genCall, timeout]);

    let parsed;
    try {
      parsed = JSON.parse(text);
    } catch {
      const match = text.match(/\{[\s\S]*\}$/);
      parsed = match ? JSON.parse(match[0]) : null;
    }

    if (!parsed || !parsed.items) {
      return res.status(502).json({ error: "Invalid model response" });
    }

    cacheSet(key, parsed);
    res.json(parsed);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to fetch resources" });
  }
});

// Speech-to-Text Endpoints
app.post("/api/speech/transcribe", upload.single("audio"), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: "No audio file provided" });
    }

    const transcript = await speechService.transcribeFile(req.file.path);
    
    // Clean up uploaded file
    fs.unlinkSync(req.file.path);
    
    res.json({
      success: true,
      transcript: transcript.text,
      confidence: transcript.confidence,
      words: transcript.words,
      speakers: transcript.speakers || []
    });
  } catch (error) {
    console.error("Transcription error:", error);
    res.status(500).json({ error: "Transcription failed", details: error.message });
  }
});

app.get("/api/speech/languages", (req, res) => {
  res.json(speechService.getSupportedLanguages());
});

app.post("/api/speech/tts", async (req, res) => {
  try {
    const { text, voice } = req.body;
    if (!text) {
      return res.status(400).json({ error: "No text provided" });
    }

    const result = await speechService.generateSpeech(text, voice);
    res.json(result);
  } catch (error) {
    console.error("TTS error:", error);
    res.status(500).json({ error: "Text-to-speech failed", details: error.message });
  }
});

// WebSocket handling for real-time transcription
wss.on('connection', (ws, req) => {
  const sessionId = Math.random().toString(36).substring(7);
  console.log(`New WebSocket connection: ${sessionId}`);

  ws.on('message', (message) => {
    try {
      const data = JSON.parse(message);
      
      if (data.type === 'start_realtime_transcription') {
        speechService.setupRealtimeTranscription(ws, sessionId);
      }
    } catch (error) {
      console.error('WebSocket message error:', error);
      ws.send(JSON.stringify({ type: 'error', message: 'Invalid message format' }));
    }
  });

  ws.on('close', () => {
    console.log(`WebSocket connection closed: ${sessionId}`);
    speechService.stopRealtimeTranscription(sessionId);
  });

  ws.on('error', (error) => {
    console.error(`WebSocket error for ${sessionId}:`, error);
    speechService.stopRealtimeTranscription(sessionId);
  });
});

app.get("/health", (req, res) => res.json({ ok: true }));

server.listen(port, () => {
  console.log(`Backend running on http://localhost:${port}`);
  console.log(`WebSocket server running on ws://localhost:${port}`);
});
